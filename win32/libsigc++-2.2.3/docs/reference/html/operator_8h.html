<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libsigc++ 2.0: operator.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/libsigc_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="../../index.html">Main Page</a> &nbsp;
  <a class="qindex" href="modules.html">Groups</a> &nbsp;
  <a class="qindex" href="namespaces.html"> Namespaces</a> &nbsp;
</center>
<hr width="100%"/>

<!-- Generated by Doxygen 1.5.1 -->
<h1>operator.h File Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesigc.html">sigc</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dereference__trait.html">sigc::dereference_trait&lt;T_type&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduces the base type of a reference or a pointer.  <a href="structsigc_1_1dereference__trait.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dereference__trait_3_01T__type_01_5_01_4.html">sigc::dereference_trait&lt;T_type*&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dereference__trait_3_01const_01T__type_01_5_01_4.html">sigc::dereference_trait&lt;const T_type*&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dereference__trait_3_01T__type_01_5_6_01_4.html">sigc::dereference_trait&lt;T_type*&amp;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dereference__trait_3_01const_01T__type_01_5_6_01_4.html">sigc::dereference_trait&lt;const T_type*&amp;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dereference__trait_3_01T__type_01_5const_01_6_01_4.html">sigc::dereference_trait&lt;T_type* const&amp;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dereference__trait_3_01const_01T__type_01_5const_01_6_01_4.html">sigc::dereference_trait&lt;const T_type* const&amp;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1arithmetic.html">sigc::arithmetic&lt;T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bitwise.html">sigc::bitwise&lt;T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1logical.html">sigc::logical&lt;T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1relational.html">sigc::relational&lt;T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1arithmetic__assign.html">sigc::arithmetic_assign&lt;T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bitwise__assign.html">sigc::bitwise_assign&lt;T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1other.html">sigc::other&lt;T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unary__arithmetic.html">sigc::unary_arithmetic&lt;T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unary__bitwise.html">sigc::unary_bitwise&lt;T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unary__logical.html">sigc::unary_logical&lt;T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unary__other.html">sigc::unary_other&lt;T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1cast__.html">sigc::cast_&lt;T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1plus.html">sigc::plus</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1minus.html">sigc::minus</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1multiplies.html">sigc::multiplies</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1divides.html">sigc::divides</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1modulus.html">sigc::modulus</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1leftshift.html">sigc::leftshift</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1rightshift.html">sigc::rightshift</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1and__.html">sigc::and_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1or__.html">sigc::or_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1xor__.html">sigc::xor_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1less.html">sigc::less</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1greater.html">sigc::greater</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1less__equal.html">sigc::less_equal</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1greater__equal.html">sigc::greater_equal</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1equal__to.html">sigc::equal_to</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1not__equal__to.html">sigc::not_equal_to</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1subscript.html">sigc::subscript</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1assign.html">sigc::assign</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1pre__increment.html">sigc::pre_increment</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1pre__decrement.html">sigc::pre_decrement</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1negate.html">sigc::negate</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1not__.html">sigc::not_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1address.html">sigc::address</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dereference.html">sigc::dereference</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1reinterpret__.html">sigc::reinterpret_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1static__.html">sigc::static_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dynamic__.html">sigc::dynamic_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__deduce__result__type.html">sigc::lambda_action_deduce_result_type&lt;T_action, T_test1, T_test2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__deduce__result__type_3_01logical_3_01T__action_01_4_00_01T__test1_00_01T__test2_01_4.html">sigc::lambda_action_deduce_result_type&lt;logical&lt;T_action&gt;, T_test1, T_test2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__deduce__result__type_3_01relational_3_01T__action_01_4_00_01T__test1_00_01T__test2_01_4.html">sigc::lambda_action_deduce_result_type&lt;relational&lt;T_action&gt;, T_test1, T_test2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__deduce__result__type_3_01arithmetic__assign_3_01T__action_01_4_00_01T__test1_00_01T__test2_01_4.html">sigc::lambda_action_deduce_result_type&lt;arithmetic_assign&lt;T_action&gt;, T_test1, T_test2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__deduce__result__type_3_01bitwise__assign_3_01T__action_01_4_00_01T__test1_00_01T__test2_01_4.html">sigc::lambda_action_deduce_result_type&lt;bitwise_assign&lt;T_action&gt;, T_test1, T_test2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__deduce__result__type_3_01other_3_01subscript_01_4_00_01T__test1_00_01T__test2_01_4.html">sigc::lambda_action_deduce_result_type&lt;other&lt;subscript&gt;, T_test1, T_test2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary__deduce__result__type.html">sigc::lambda_action_unary_deduce_result_type&lt;T_action, T_test&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__convert__deduce__result__type.html">sigc::lambda_action_convert_deduce_result_type&lt;T_action, T_type, T_test&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary__deduce__result__type_3_01unary__logical_3_01T__action_01_4_00_01T__test_01_4.html">sigc::lambda_action_unary_deduce_result_type&lt;unary_logical&lt;T_action&gt;, T_test&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary__deduce__result__type_3_01unary__other_3_01address_01_4_00_01T__test_01_4.html">sigc::lambda_action_unary_deduce_result_type&lt;unary_other&lt;address&gt;, T_test&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary__deduce__result__type_3_01unary__other_3_01dereference_01_4_00_01T__test_01_4.html">sigc::lambda_action_unary_deduce_result_type&lt;unary_other&lt;dereference&gt;, T_test&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action.html">sigc::lambda_action&lt;T_action&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary.html">sigc::lambda_action_unary&lt;T_action&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__convert.html">sigc::lambda_action_convert&lt;T_action, T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic_3_01plus_01_4_01_4.html">sigc::lambda_action&lt;arithmetic&lt;plus&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic_3_01minus_01_4_01_4.html">sigc::lambda_action&lt;arithmetic&lt;minus&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic_3_01multiplies_01_4_01_4.html">sigc::lambda_action&lt;arithmetic&lt;multiplies&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic_3_01divides_01_4_01_4.html">sigc::lambda_action&lt;arithmetic&lt;divides&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic_3_01modulus_01_4_01_4.html">sigc::lambda_action&lt;arithmetic&lt;modulus&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise_3_01leftshift_01_4_01_4.html">sigc::lambda_action&lt;bitwise&lt;leftshift&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise_3_01rightshift_01_4_01_4.html">sigc::lambda_action&lt;bitwise&lt;rightshift&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise_3_01and___01_4_01_4.html">sigc::lambda_action&lt;bitwise&lt;and_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise_3_01or___01_4_01_4.html">sigc::lambda_action&lt;bitwise&lt;or_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise_3_01xor___01_4_01_4.html">sigc::lambda_action&lt;bitwise&lt;xor_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01logical_3_01and___01_4_01_4.html">sigc::lambda_action&lt;logical&lt;and_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01logical_3_01or___01_4_01_4.html">sigc::lambda_action&lt;logical&lt;or_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01relational_3_01less_01_4_01_4.html">sigc::lambda_action&lt;relational&lt;less&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01relational_3_01greater_01_4_01_4.html">sigc::lambda_action&lt;relational&lt;greater&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01relational_3_01less__equal_01_4_01_4.html">sigc::lambda_action&lt;relational&lt;less_equal&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01relational_3_01greater__equal_01_4_01_4.html">sigc::lambda_action&lt;relational&lt;greater_equal&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01relational_3_01equal__to_01_4_01_4.html">sigc::lambda_action&lt;relational&lt;equal_to&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01relational_3_01not__equal__to_01_4_01_4.html">sigc::lambda_action&lt;relational&lt;not_equal_to&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic__assign_3_01plus_01_4_01_4.html">sigc::lambda_action&lt;arithmetic_assign&lt;plus&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic__assign_3_01minus_01_4_01_4.html">sigc::lambda_action&lt;arithmetic_assign&lt;minus&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic__assign_3_01multiplies_01_4_01_4.html">sigc::lambda_action&lt;arithmetic_assign&lt;multiplies&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic__assign_3_01divides_01_4_01_4.html">sigc::lambda_action&lt;arithmetic_assign&lt;divides&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic__assign_3_01modulus_01_4_01_4.html">sigc::lambda_action&lt;arithmetic_assign&lt;modulus&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise__assign_3_01leftshift_01_4_01_4.html">sigc::lambda_action&lt;bitwise_assign&lt;leftshift&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise__assign_3_01rightshift_01_4_01_4.html">sigc::lambda_action&lt;bitwise_assign&lt;rightshift&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise__assign_3_01and___01_4_01_4.html">sigc::lambda_action&lt;bitwise_assign&lt;and_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise__assign_3_01or___01_4_01_4.html">sigc::lambda_action&lt;bitwise_assign&lt;or_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise__assign_3_01xor___01_4_01_4.html">sigc::lambda_action&lt;bitwise_assign&lt;xor_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01other_3_01subscript_01_4_01_4.html">sigc::lambda_action&lt;other&lt;subscript&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01other_3_01assign_01_4_01_4.html">sigc::lambda_action&lt;other&lt;assign&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__arithmetic_3_01pre__increment_01_4_01_4.html">sigc::lambda_action_unary&lt;unary_arithmetic&lt;pre_increment&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__arithmetic_3_01pre__decrement_01_4_01_4.html">sigc::lambda_action_unary&lt;unary_arithmetic&lt;pre_decrement&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__arithmetic_3_01negate_01_4_01_4.html">sigc::lambda_action_unary&lt;unary_arithmetic&lt;negate&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__bitwise_3_01not___01_4_01_4.html">sigc::lambda_action_unary&lt;unary_bitwise&lt;not_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__logical_3_01not___01_4_01_4.html">sigc::lambda_action_unary&lt;unary_logical&lt;not_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__other_3_01address_01_4_01_4.html">sigc::lambda_action_unary&lt;unary_other&lt;address&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__other_3_01dereference_01_4_01_4.html">sigc::lambda_action_unary&lt;unary_other&lt;dereference&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__convert_3_01cast___3_01reinterpret___01_4_00_01T__type_01_4.html">sigc::lambda_action_convert&lt;cast_&lt;reinterpret_&gt;, T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__convert_3_01cast___3_01static___01_4_00_01T__type_01_4.html">sigc::lambda_action_convert&lt;cast_&lt;static_&gt;, T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__convert_3_01cast___3_01dynamic___01_4_00_01T__type_01_4.html">sigc::lambda_action_convert&lt;cast_&lt;dynamic_&gt;, T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__operator.html">sigc::lambda_operator&lt;T_action, T_type1, T_type2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__operator_1_1deduce__result__type.html">sigc::lambda_operator&lt;T_action, T_type1, T_type2&gt;::deduce_result_type&lt;T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__operator__unary.html">sigc::lambda_operator_unary&lt;T_action, T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__operator__unary_1_1deduce__result__type.html">sigc::lambda_operator_unary&lt;T_action, T_type&gt;::deduce_result_type&lt;T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__operator__convert.html">sigc::lambda_operator_convert&lt;T_action, T_type, T_arg&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__operator__convert_1_1deduce__result__type.html">sigc::lambda_operator_convert&lt;T_action, T_type, T_arg&gt;::deduce_result_type&lt;T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_lambda_action, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#eff5a0299fefc2899b6a920ec35539b1">sigc::visit_each</a> (const T_action&amp; _A_action, const lambda_operator&lt;T_lambda_action, T_arg1, T_arg2 &gt;&amp; _A_target)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_lambda_action, class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#63a15030d38a903406a7f0e3b4ef220a">sigc::visit_each</a> (const T_action&amp; _A_action, const lambda_operator_unary&lt;T_lambda_action, T_arg&gt;&amp; _A_target)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_lambda_action, class T_type, class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#3413af839d2a7c15cbcd24e5d3098542">sigc::visit_each</a> (const T_action&amp; _A_action, const lambda_operator_convert&lt;T_lambda_action, T_type, T_arg&gt;&amp; _A_target)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic&lt;<br>
 plus &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#29d226d0e89c123a6a99df7cf7049e98">sigc::operator+</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic&lt;<br>
 plus &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#cc0c03760fce65203d5f67f23a05aee7">sigc::operator+</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic&lt;<br>
 plus &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#74d41ed6e82b12e9d2079776d1381a1b">sigc::operator+</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic&lt;<br>
 minus &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#26c54de4f570705ef709f745a1ded9c7">sigc::operator-</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic&lt;<br>
 minus &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ebf7d41a285af52c58329c66183aca15">sigc::operator-</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic&lt;<br>
 minus &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#000e30854e2ad97c82db1c8e55ae9c58">sigc::operator-</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic&lt;<br>
 multiplies &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#96302d55d9f9487b85bd723983bf7dc8">sigc::operator*</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic&lt;<br>
 multiplies &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#b8250f41a97fbcaf00f38e3cdac71880">sigc::operator*</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic&lt;<br>
 multiplies &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#db9970b1407a0d915eefd423acfc2af6">sigc::operator*</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic&lt;<br>
 divides &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#2cd49ce61ca95eef20291ceaaa14f7f3">sigc::operator/</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic&lt;<br>
 divides &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#04d7fd3f8ecfe2ace16a5f03c318a56d">sigc::operator/</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic&lt;<br>
 divides &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#778da0346854b55c0605811e427f7ece">sigc::operator/</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic&lt;<br>
 modulus &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#448f704e10cf7099d202544144257829">sigc::operator%</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic&lt;<br>
 modulus &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#0df1bd3cac2a2bfbb43d250aec11b171">sigc::operator%</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic&lt;<br>
 modulus &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#8900336dc8fbdcc1719095a98728aa07">sigc::operator%</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise&lt;<br>
 leftshift &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#2be0aea0eb8880432737d42fa166a226">sigc::operator&lt;&lt;</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise&lt;<br>
 leftshift &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#43931fdef62a0517ba0924de2f82d0a9">sigc::operator&lt;&lt;</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise&lt;<br>
 leftshift &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#15266193ad2aad0a0b5c77b9d54f778e">sigc::operator&lt;&lt;</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise&lt;<br>
 rightshift &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#f82dddd5da2b904553cac0cbe28fbdef">sigc::operator&gt;&gt;</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise&lt;<br>
 rightshift &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#5d32e408b09d4b18017401a618deca22">sigc::operator&gt;&gt;</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise&lt;<br>
 rightshift &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#961c52af18d38be10448d6305875ec42">sigc::operator&gt;&gt;</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise&lt;<br>
 and_ &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#461df6e22a0f398518cba4a6d188afc9">sigc::operator&amp;</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise&lt;<br>
 and_ &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#c98c7424a1a331909cfe0e2a0761c18f">sigc::operator&amp;</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise&lt;<br>
 and_ &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#cf462bfb7b85b19e4e4308c9a27ffcc2">sigc::operator&amp;</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise&lt;<br>
 or_ &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#7d613863e01f8cf39a3f7a67be586b37">sigc::operator|</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise&lt;<br>
 or_ &gt;, T_arg1, typename unwrap_reference&lt;<br>
 T_arg2 &gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#79c58fce0596a170e3eb32aa589aa573">sigc::operator|</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise&lt;<br>
 or_ &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#2298b1d7394469e603ef17122d29e2c5">sigc::operator|</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise&lt;<br>
 xor_ &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#9bd6e35894b866758aa37ec441e46c1b">sigc::operator^</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise&lt;<br>
 xor_ &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#f5b039f488caaf8422ce7e04f8d22fd2">sigc::operator^</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise&lt;<br>
 xor_ &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#455402cbd5b9af2923150b24f1b586ed">sigc::operator^</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;logical&lt;<br>
 and_ &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#f68affa8bbefac3b556d333240a97f3e">sigc::operator&amp;&amp;</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;logical&lt;<br>
 and_ &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#bca5b3586ae165f374e0ecda6e742368">sigc::operator&amp;&amp;</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;logical&lt;<br>
 and_ &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#9a43e8f2ed62653f3cdd1c7fc822eac1">sigc::operator&amp;&amp;</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;logical&lt;<br>
 or_ &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#5c4eea4d6cfb47d019091f7b64177dcc">sigc::operator||</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;logical&lt;<br>
 or_ &gt;, T_arg1, typename unwrap_reference&lt;<br>
 T_arg2 &gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#be7b14c8d37e24cc62259aba382f5b3e">sigc::operator||</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;logical&lt;<br>
 or_ &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#b185848c59fea219a747cb1009f1c881">sigc::operator||</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;relational&lt;<br>
 less &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#64587ad0e3a569be542d546b9b1d9829">sigc::operator&lt;</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;relational&lt;<br>
 less &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a0f064417347c15e6c2eee46645f4b58">sigc::operator&lt;</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;relational&lt;<br>
 less &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#e84ae7410cde285a4062beec3f2581dd">sigc::operator&lt;</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;relational&lt;<br>
 greater &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#82df52344c1995f4b7f66efa2c6dd1e1">sigc::operator&gt;</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;relational&lt;<br>
 greater &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#aed6caf81d925870fbc306ecaf562a9a">sigc::operator&gt;</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;relational&lt;<br>
 greater &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#56f75748c8b6018401b8f82a93f29a58">sigc::operator&gt;</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;relational&lt;<br>
 less_equal &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#276ae53620c9234c7964816aa94ba476">sigc::operator&lt;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;relational&lt;<br>
 less_equal &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ffb5949de125154ba78a9fab53e5c88f">sigc::operator&lt;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;relational&lt;<br>
 less_equal &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#4a9e25129fc0832aa465ce7ec679a1be">sigc::operator&lt;=</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;relational&lt;<br>
 greater_equal &gt;, T_arg1,<br>
 T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#e1c71b2dfbafd2701d1ee7be0a5c603b">sigc::operator&gt;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;relational&lt;<br>
 greater_equal &gt;, T_arg1,<br>
 typename unwrap_reference&lt;<br>
 T_arg2 &gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#109def8701355bae896321317c9fbda3">sigc::operator&gt;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;relational&lt;<br>
 greater_equal &gt;, typename <br>
unwrap_reference&lt; T_arg1 <br>
&gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#8783dd0b543f6b51467ec1256a694174">sigc::operator&gt;=</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;relational&lt;<br>
 equal_to &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#3d4a437822ac13a0b06f8d629f162441">sigc::operator==</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;relational&lt;<br>
 equal_to &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#6a642d0f9179d581a95ac21ad10003b5">sigc::operator==</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;relational&lt;<br>
 equal_to &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#934ffbd686558b72a1ee12e4d9207a93">sigc::operator==</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;relational&lt;<br>
 not_equal_to &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#2e406f67fa7336e1e6af7f2b6de89563">sigc::operator!=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;relational&lt;<br>
 not_equal_to &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#35550c6b98eab98d75f088abb1c06f6d">sigc::operator!=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;relational&lt;<br>
 not_equal_to &gt;, typename <br>
unwrap_reference&lt; T_arg1 <br>
&gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#0fc828769dcf706797f1b39f88b770f9">sigc::operator!=</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic_assign&lt;<br>
 plus &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#e4450395ac4750ab095b170da8dfc0a0">sigc::operator+=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic_assign&lt;<br>
 plus &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#334380d2c5ffd5febefb5aa0bfc6d162">sigc::operator+=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic_assign&lt;<br>
 plus &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#4f0fa4bcad9e6a2f2d084ae4d0253acc">sigc::operator+=</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic_assign&lt;<br>
 minus &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#053d463f15272d949eddd17c1eb6057c">sigc::operator-=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic_assign&lt;<br>
 minus &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#098d8644120cfbecfce6c2fdf3dcf4fe">sigc::operator-=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic_assign&lt;<br>
 minus &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#3f5f33195e31cf10b663d60bee6624be">sigc::operator-=</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic_assign&lt;<br>
 multiplies &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#f0221188780339a72bddffa5e64a24a6">sigc::operator*=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic_assign&lt;<br>
 multiplies &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#4310d9b5aeb6048b08cce89273d11d9c">sigc::operator*=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic_assign&lt;<br>
 multiplies &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#db177314c99341fd5b57f65989a31e10">sigc::operator*=</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic_assign&lt;<br>
 divides &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#8749ada1d603fb667f3170e056c3d3fe">sigc::operator/=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic_assign&lt;<br>
 divides &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#190f94964b496b4389ff0695459c97f2">sigc::operator/=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic_assign&lt;<br>
 divides &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#91c8284788f629046b289b1b8bb92fd2">sigc::operator/=</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic_assign&lt;<br>
 modulus &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a22758b40768e4e1d5292711819e73f6">sigc::operator%=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic_assign&lt;<br>
 modulus &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#69bde4f0ffcf252e7b41e28c541943ba">sigc::operator%=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;arithmetic_assign&lt;<br>
 modulus &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#c5379cb4329503d13767b738a076b157">sigc::operator%=</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise_assign&lt;<br>
 leftshift &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#717ad3389bb00a107750f9134d6170ef">sigc::operator&lt;&lt;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise_assign&lt;<br>
 leftshift &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#7d37efde4fa6742ef6090076ffde6d26">sigc::operator&lt;&lt;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise_assign&lt;<br>
 leftshift &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a3c8ebf217044832c473285315d0c978">sigc::operator&lt;&lt;=</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise_assign&lt;<br>
 rightshift &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#002b4794715b5156dd45588364e52263">sigc::operator&gt;&gt;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise_assign&lt;<br>
 rightshift &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#898e016d767b6caa5dbf55b2df889524">sigc::operator&gt;&gt;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise_assign&lt;<br>
 rightshift &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#77622d65d029ad3e13ed40e5c6506195">sigc::operator&gt;&gt;=</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise_assign&lt;<br>
 and_ &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a25d6e499bf8c44cfd04d2900ca4a156">sigc::operator&amp;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise_assign&lt;<br>
 and_ &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#cac27c3e543578eb522f66c1612435bb">sigc::operator&amp;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise_assign&lt;<br>
 and_ &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#56cab772bbbecd16ed69b0b3897d7622">sigc::operator&amp;=</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise_assign&lt;<br>
 or_ &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#188bc271d74500df8b312869b7db9100">sigc::operator|=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise_assign&lt;<br>
 or_ &gt;, T_arg1, typename unwrap_reference&lt;<br>
 T_arg2 &gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#38281683e4f30ae38ebd9a77acadd68c">sigc::operator|=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise_assign&lt;<br>
 or_ &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#5a32da57863bbe61bca7ef039e1e6c3a">sigc::operator|=</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise_assign&lt;<br>
 xor_ &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#2108c7da0f2be4495e270b156f30cedd">sigc::operator^=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise_assign&lt;<br>
 xor_ &gt;, T_arg1, typename <br>
unwrap_reference&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#9fa6e2ff33616025e04285d6ad985b87">sigc::operator^=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator&lt;bitwise_assign&lt;<br>
 xor_ &gt;, typename unwrap_reference&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a1f413cd83d012ce882fcb2654bd9ca2">sigc::operator^=</a> (const T_arg1&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator_unary&lt;<br>
 unary_arithmetic&lt; pre_increment &gt;,<br>
 T_arg &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#e9659bd5e4dafbdbef94794ab280fd44">sigc::operator++</a> (const lambda&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator_unary&lt;<br>
 unary_arithmetic&lt; pre_decrement &gt;,<br>
 T_arg &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#979840b7fcd28955b01524d2d352a731">sigc::operator--</a> (const lambda&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator_unary&lt;<br>
 unary_arithmetic&lt; negate &gt;,<br>
 T_arg &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a1e0215bf7c7cec50a46b4fbc5e09f88">sigc::operator-</a> (const lambda&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator_unary&lt;<br>
 unary_bitwise&lt;not_ &gt;, T_arg &gt;&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#db7ab85e9d37fd0d23e68c39d4c9f7ae">sigc::operator~</a> (const lambda&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator_unary&lt;<br>
 unary_logical&lt;not_ &gt;, T_arg &gt;&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#1f087b34043a9ddd59fd58da582e4349">sigc::operator!</a> (const lambda&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator_unary&lt;<br>
 unary_other&lt;address &gt;, T_arg &gt;&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#8d9d07ddf7ce8aec640d92b45db91309">sigc::operator&amp;</a> (const lambda&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator_unary&lt;<br>
 unary_other&lt; dereference &gt;,<br>
 T_arg &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#977f37aadcfd2fc5045800bdfd81cde1">sigc::operator*</a> (const lambda&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type, class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator_convert&lt;<br>
 cast_&lt; reinterpret_ &gt;, T_type,<br>
 typename unwrap_lambda_type&lt;<br>
 T_arg &gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#0ba07befc70db9c92da9a0ba298b7c4e">sigc::reinterpret_cast_</a> (const T_arg&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type, class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator_convert&lt;<br>
 cast_&lt; static_ &gt;, T_type,<br>
 typename unwrap_lambda_type&lt;<br>
 T_arg &gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#89e8b6d6a025937d9376edf132e369e9">sigc::static_cast_</a> (const T_arg&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type, class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">lambda&lt; lambda_operator_convert&lt;<br>
 cast_&lt; dynamic_ &gt;, T_type,<br>
 typename unwrap_lambda_type&lt;<br>
 T_arg &gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#7eb410f49742a727c3292269b99771a2">sigc::dynamic_cast_</a> (const T_arg&amp; a)</td></tr>

</table>
<hr><address><small>
Generated for libsigc++ 2.0 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.5.1 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
