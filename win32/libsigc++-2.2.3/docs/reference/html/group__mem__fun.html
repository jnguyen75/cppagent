<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libsigc++ 2.0: mem_fun()</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/libsigc_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="../../index.html">Main Page</a> &nbsp;
  <a class="qindex" href="modules.html">Groups</a> &nbsp;
  <a class="qindex" href="namespaces.html"> Namespaces</a> &nbsp;
</center>
<hr width="100%"/>

<!-- Generated by Doxygen 1.5.1 -->
<h1>mem_fun()<br>
<small>
[<a class="el" href="group__functors.html">Functors</a>]</small>
</h1>
<p>
Collaboration diagram for mem_fun():<center><table><tr><td><img src="group__mem__fun.png" border="0" alt="" usemap="#group____mem____fun_map">
<map name="group____mem____fun_map">
<area href="group__functors.html" shape="rect" coords="7,5,81,32" alt="">
</map></td></tr></table></center>
<a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602">mem_fun()</a> is used to convert a pointer to a method to a functor.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor0.html">sigc::mem_functor0&lt;T_return, T_obj&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a> wraps methods with 0 argument(s).  <a href="classsigc_1_1mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor1.html">sigc::mem_functor1&lt;T_return, T_obj, T_arg1&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a> wraps methods with 1 argument(s).  <a href="classsigc_1_1mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor2.html">sigc::mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a> wraps methods with 2 argument(s).  <a href="classsigc_1_1mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor3.html">sigc::mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a> wraps methods with 3 argument(s).  <a href="classsigc_1_1mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor4.html">sigc::mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a> wraps methods with 4 argument(s).  <a href="classsigc_1_1mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor5.html">sigc::mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a> wraps methods with 5 argument(s).  <a href="classsigc_1_1mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor6.html">sigc::mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a> wraps methods with 6 argument(s).  <a href="classsigc_1_1mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor7.html">sigc::mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a> wraps methods with 7 argument(s).  <a href="classsigc_1_1mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor0.html">sigc::const_mem_functor0&lt;T_return, T_obj&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a> wraps const methods with 0 argument(s).  <a href="classsigc_1_1const__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor1.html">sigc::const_mem_functor1&lt;T_return, T_obj, T_arg1&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a> wraps const methods with 1 argument(s).  <a href="classsigc_1_1const__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor2.html">sigc::const_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a> wraps const methods with 2 argument(s).  <a href="classsigc_1_1const__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor3.html">sigc::const_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a> wraps const methods with 3 argument(s).  <a href="classsigc_1_1const__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor4.html">sigc::const_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a> wraps const methods with 4 argument(s).  <a href="classsigc_1_1const__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor5.html">sigc::const_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a> wraps const methods with 5 argument(s).  <a href="classsigc_1_1const__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor6.html">sigc::const_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a> wraps const methods with 6 argument(s).  <a href="classsigc_1_1const__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor7.html">sigc::const_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a> wraps const methods with 7 argument(s).  <a href="classsigc_1_1const__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor0.html">sigc::volatile_mem_functor0&lt;T_return, T_obj&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a> wraps volatile methods with 0 argument(s).  <a href="classsigc_1_1volatile__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor1.html">sigc::volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a> wraps volatile methods with 1 argument(s).  <a href="classsigc_1_1volatile__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor2.html">sigc::volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a> wraps volatile methods with 2 argument(s).  <a href="classsigc_1_1volatile__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor3.html">sigc::volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a> wraps volatile methods with 3 argument(s).  <a href="classsigc_1_1volatile__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor4.html">sigc::volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a> wraps volatile methods with 4 argument(s).  <a href="classsigc_1_1volatile__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor5.html">sigc::volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a> wraps volatile methods with 5 argument(s).  <a href="classsigc_1_1volatile__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor6.html">sigc::volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a> wraps volatile methods with 6 argument(s).  <a href="classsigc_1_1volatile__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor7.html">sigc::volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a> wraps volatile methods with 7 argument(s).  <a href="classsigc_1_1volatile__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">sigc::const_volatile_mem_functor0&lt;T_return, T_obj&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a> wraps const volatile methods with 0 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">sigc::const_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a> wraps const volatile methods with 1 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">sigc::const_volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a> wraps const volatile methods with 2 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">sigc::const_volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a> wraps const volatile methods with 3 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">sigc::const_volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a> wraps const volatile methods with 4 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">sigc::const_volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a> wraps const volatile methods with 5 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">sigc::const_volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a> wraps const volatile methods with 6 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">sigc::const_volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a> wraps const volatile methods with 7 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor0.html">sigc::bound_mem_functor0&lt;T_return, T_obj&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a> encapsulates a method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor1.html">sigc::bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a> encapsulates a method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor2.html">sigc::bound_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a> encapsulates a method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor3.html">sigc::bound_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a> encapsulates a method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor4.html">sigc::bound_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a> encapsulates a method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor5.html">sigc::bound_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a> encapsulates a method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor6.html">sigc::bound_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a> encapsulates a method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor7.html">sigc::bound_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a> encapsulates a method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">sigc::bound_const_mem_functor0&lt;T_return, T_obj&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a> encapsulates a const method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">sigc::bound_const_mem_functor1&lt;T_return, T_obj, T_arg1&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a> encapsulates a const method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">sigc::bound_const_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a> encapsulates a const method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">sigc::bound_const_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a> encapsulates a const method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">sigc::bound_const_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a> encapsulates a const method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">sigc::bound_const_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a> encapsulates a const method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">sigc::bound_const_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a> encapsulates a const method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">sigc::bound_const_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a> encapsulates a const method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">sigc::bound_volatile_mem_functor0&lt;T_return, T_obj&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a> encapsulates a volatile method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">sigc::bound_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a> encapsulates a volatile method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">sigc::bound_volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a> encapsulates a volatile method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">sigc::bound_volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a> encapsulates a volatile method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">sigc::bound_volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a> encapsulates a volatile method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">sigc::bound_volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a> encapsulates a volatile method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">sigc::bound_volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a> encapsulates a volatile method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">sigc::bound_volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a> encapsulates a volatile method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0&lt;T_return, T_obj&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a> encapsulates a const volatile method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a> encapsulates a const volatile method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a> encapsulates a const volatile method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a> encapsulates a const volatile method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a> encapsulates a const volatile method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a> encapsulates a const volatile method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a> encapsulates a const volatile method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a> encapsulates a const volatile method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g8a0e4bdca79dde7347318bff4d6e1eda">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor0&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g8a0e4bdca79dde7347318bff4d6e1eda"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gff3264460325cf2a34cc0502fec7b8b7">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#gff3264460325cf2a34cc0502fec7b8b7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g497c57551529e8721861cedc1c3d5121">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g497c57551529e8721861cedc1c3d5121"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g5cc57f71faadc4101e7a10e0b5d7317f">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g5cc57f71faadc4101e7a10e0b5d7317f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g66608a108aa332faf3c3bfd418655fcb">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g66608a108aa332faf3c3bfd418655fcb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gee9534127cddea3f7b3e5461f768a42b">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#gee9534127cddea3f7b3e5461f768a42b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g259c308cca0572400aaed34384eafbe3">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g259c308cca0572400aaed34384eafbe3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g56f7d4d8f86928edb83e1f65702a2978">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g56f7d4d8f86928edb83e1f65702a2978"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga0d89783277d6e9dede11eda2ff6c75a">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor0&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#ga0d89783277d6e9dede11eda2ff6c75a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g20b2c11c8fb2a9e0bb86ad4c66c9c2e7">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor1&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g20b2c11c8fb2a9e0bb86ad4c66c9c2e7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g8ef4b45b1dcecb9270562c030e38e339">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g8ef4b45b1dcecb9270562c030e38e339"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3c16c17557fcebdd7573fa6b2ed0dcf">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#ga3c16c17557fcebdd7573fa6b2ed0dcf"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g6bbf2084c41ca86d2ab99e21adf28f30">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g6bbf2084c41ca86d2ab99e21adf28f30"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g21e843c71a56dba1d507c9a92fad48d1">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g21e843c71a56dba1d507c9a92fad48d1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g5af2a45e22e6f53837fa0b5f9de0ad57">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g5af2a45e22e6f53837fa0b5f9de0ad57"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gf8ba948d4075a160a3c887d5bc29fe38">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#gf8ba948d4075a160a3c887d5bc29fe38"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g167fc8e84727e8b465c5f569da18fe7c">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor0&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g167fc8e84727e8b465c5f569da18fe7c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gc99d35f92c4859d7ba58c0f8dbee8a59">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#gc99d35f92c4859d7ba58c0f8dbee8a59"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gfd990e80dc9ec40599b0e66526334ed3">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#gfd990e80dc9ec40599b0e66526334ed3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g8df64a5ef08edf9a3bffd45888cf6566">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g8df64a5ef08edf9a3bffd45888cf6566"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g115420b91c53ff373128c8d9c5389e26">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g115420b91c53ff373128c8d9c5389e26"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g59db8f4f6bf774aac7a42e4db22fe525">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g59db8f4f6bf774aac7a42e4db22fe525"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g4fe42d39978e3534528e704a2ef69d19">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g4fe42d39978e3534528e704a2ef69d19"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ged1e318f76b0b4560f7f7f15348bf74f">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#ged1e318f76b0b4560f7f7f15348bf74f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g7f0b3a137305d0da984cfcaa69028645">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor0&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g7f0b3a137305d0da984cfcaa69028645"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gfa45bea25d6b97dd4215c61845eb276b">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#gfa45bea25d6b97dd4215c61845eb276b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g8bbfab43840801b698deebdbcced31b8">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g8bbfab43840801b698deebdbcced31b8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g4e8a4b740ba229328323782cdff5defc">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g4e8a4b740ba229328323782cdff5defc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ge32dedba98d5616ffed3bf45564b5925">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#ge32dedba98d5616ffed3bf45564b5925"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g0a7438643be599bd0687c6de6af6ec2b">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#g0a7438643be599bd0687c6de6af6ec2b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gcb29a90ac86fe224d4074619e0117cb8">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#gcb29a90ac86fe224d4074619e0117cb8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaa2493ee4790a02fad2dfd44e3e4e1f6">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="#gaa2493ee4790a02fad2dfd44e3e4e1f6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor0&lt;T_return, T_obj&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gd6f8ec28efe46a939923e0ae83aa2888">sigc::mem_fun0</a> (T_return(T_obj::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method.  <a href="#gd6f8ec28efe46a939923e0ae83aa2888"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor1&lt; T_return, T_obj,<br>
 T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gc54cbcf11289d7b7fe15dff1fc2e84f4">sigc::mem_fun1</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method.  <a href="#gc54cbcf11289d7b7fe15dff1fc2e84f4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor2&lt; T_return, T_obj,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g353bb1c7c03796bafe5ed2e52f012980">sigc::mem_fun2</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method.  <a href="#g353bb1c7c03796bafe5ed2e52f012980"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor3&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga603c1c92cc9140a13d89256724de663">sigc::mem_fun3</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method.  <a href="#ga603c1c92cc9140a13d89256724de663"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor4&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g9e5cce0968f3f2a79240922ebc1b6745">sigc::mem_fun4</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method.  <a href="#g9e5cce0968f3f2a79240922ebc1b6745"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor5&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gb0cbec1f295cbf8283208dedf5ab9ac7">sigc::mem_fun5</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method.  <a href="#gb0cbec1f295cbf8283208dedf5ab9ac7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor6&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g1c9c46a46db3d5d01d582b6867665c7c">sigc::mem_fun6</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method.  <a href="#g1c9c46a46db3d5d01d582b6867665c7c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor7&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gfb7d7c8968bebcfea74f08c3eb55b14f">sigc::mem_fun7</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method.  <a href="#gfb7d7c8968bebcfea74f08c3eb55b14f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor0&lt; T_return,<br>
 T_obj &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ge75bc5b94c36e78775ff5b5f20767baf">sigc::mem_fun0</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#ge75bc5b94c36e78775ff5b5f20767baf"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor1&lt; T_return,<br>
 T_obj, T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g3d62fea84f3f77ac5a315cebe5286b47">sigc::mem_fun1</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#g3d62fea84f3f77ac5a315cebe5286b47"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor2&lt; T_return,<br>
 T_obj, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gbb30783d2b0ac099089d70274d4459fb">sigc::mem_fun2</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#gbb30783d2b0ac099089d70274d4459fb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor3&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gf19bbb21b4b903e1a6b97fea87e90663">sigc::mem_fun3</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#gf19bbb21b4b903e1a6b97fea87e90663"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor4&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gb1a00dd97f2ca5e21b2b4f73fea4053b">sigc::mem_fun4</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#gb1a00dd97f2ca5e21b2b4f73fea4053b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor5&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga34194e868680c9146f8d143ddbdd8a8">sigc::mem_fun5</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#ga34194e868680c9146f8d143ddbdd8a8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor6&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g4908458d042d70f91be5f72547518e4f">sigc::mem_fun6</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#g4908458d042d70f91be5f72547518e4f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor7&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g750c42aaea61ec588daf64d4111e8429">sigc::mem_fun7</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#g750c42aaea61ec588daf64d4111e8429"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor0&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gc725cb282b0c611c67a270a7821e173f">sigc::mem_fun0</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#gc725cb282b0c611c67a270a7821e173f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor1&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g211bd1f151b5936a549a8d8e6ab911bf">sigc::mem_fun1</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#g211bd1f151b5936a549a8d8e6ab911bf"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor2&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g55aafe144e22f4df7fe785c1eec839ca">sigc::mem_fun2</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#g55aafe144e22f4df7fe785c1eec839ca"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor3&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g3b7fd6101534e982aa29c0308ce69006">sigc::mem_fun3</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#g3b7fd6101534e982aa29c0308ce69006"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor4&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gdedf83e65a2aca0d3aa4ac0b6d68ccd8">sigc::mem_fun4</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#gdedf83e65a2aca0d3aa4ac0b6d68ccd8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor5&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g61cec9d9ec3d399f0d14a3b2edb6fecc">sigc::mem_fun5</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#g61cec9d9ec3d399f0d14a3b2edb6fecc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor6&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gf6a1bce5fc8d6a117124874f2fa6ab18">sigc::mem_fun6</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#gf6a1bce5fc8d6a117124874f2fa6ab18"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor7&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g208d42856768ebe922a1418f7250ca31">sigc::mem_fun7</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#g208d42856768ebe922a1418f7250ca31"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor0&lt;T_return, T_obj&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602">sigc::mem_fun</a> (T_return(T_obj::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method.  <a href="#g7d9ea809173f48bf5c76cf1989591602"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor1&lt; T_return, T_obj,<br>
 T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gfa7e13948472a451e25485f2c5001028">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method.  <a href="#gfa7e13948472a451e25485f2c5001028"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor2&lt; T_return, T_obj,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g13a02e1edfe8b4450aba9f9629c69183">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method.  <a href="#g13a02e1edfe8b4450aba9f9629c69183"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor3&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g8a171185d53c5ef87adb18bdd1d34aca">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method.  <a href="#g8a171185d53c5ef87adb18bdd1d34aca"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor4&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g17d792c86d3251c2045987c4dec04494">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method.  <a href="#g17d792c86d3251c2045987c4dec04494"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor5&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g72ce5f7bfd24897f48d0ebd676bcbe5a">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method.  <a href="#g72ce5f7bfd24897f48d0ebd676bcbe5a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor6&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gdbb4cac2850f0f61f6d5f9e17e02c7ba">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method.  <a href="#gdbb4cac2850f0f61f6d5f9e17e02c7ba"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor7&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gf995826321b8808ce8839e4abbb0550d">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method.  <a href="#gf995826321b8808ce8839e4abbb0550d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor0&lt; T_return,<br>
 T_obj &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g51fa4e5052666f6738abbaa628ec6cc2">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#g51fa4e5052666f6738abbaa628ec6cc2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor1&lt; T_return,<br>
 T_obj, T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ge53b7ef4bd43363998aff8a589bc254a">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#ge53b7ef4bd43363998aff8a589bc254a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor2&lt; T_return,<br>
 T_obj, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g47ec248386b6998e5f8b9a80191e4d5d">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#g47ec248386b6998e5f8b9a80191e4d5d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor3&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g6e58e3cf7e4f1b5fbcb85736369d018c">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#g6e58e3cf7e4f1b5fbcb85736369d018c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor4&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g1b200788ce261aef52a8dadaa1e2c9aa">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#g1b200788ce261aef52a8dadaa1e2c9aa"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor5&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g81b830d633d756ca945bac75c4b2f8e8">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#g81b830d633d756ca945bac75c4b2f8e8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor6&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g975cacf1b6fdd69a93c2f5ba0973f780">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#g975cacf1b6fdd69a93c2f5ba0973f780"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor7&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gb37fdbceea44a66560bb16345e1593e6">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#gb37fdbceea44a66560bb16345e1593e6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor0&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gdd76171e23f2e904c7f01264228440fc">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#gdd76171e23f2e904c7f01264228440fc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor1&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g23120ad94420b72a8761423c5bab2bec">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#g23120ad94420b72a8761423c5bab2bec"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor2&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g34e7257908fb33b2582f686ac51e1d74">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#g34e7257908fb33b2582f686ac51e1d74"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor3&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gc41f442c5e8a533e98cce0d7df02efe6">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#gc41f442c5e8a533e98cce0d7df02efe6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor4&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gb1b6c289aa5b68e382c259bb5c35aa95">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#gb1b6c289aa5b68e382c259bb5c35aa95"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor5&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g8fbf4b5621eda8f79ba2be75bd7badd4">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#g8fbf4b5621eda8f79ba2be75bd7badd4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor6&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gfc3676e579d8e7b037c0589b2ab12270">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#gfc3676e579d8e7b037c0589b2ab12270"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor7&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gcdcec06e66f0ba9a970e530c953d60b6">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#gcdcec06e66f0ba9a970e530c953d60b6"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602">mem_fun()</a> is used to convert a pointer to a method to a functor. 
<p>
Optionally a reference or pointer to an object can be bound to the functor. Note that only if the object type inherits from <a class="el" href="structsigc_1_1trackable.html">sigc::trackable</a> the slot is cleared automatically when the object goes out of scope!<p>
If the member function pointer is to an overloaded type, you must specify the types using template arguments starting with the first argument. It is not necessary to supply the return type.<p>
<dl class="user" compact><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment">   <span class="keyword">struct </span>foo : <span class="keyword">public</span> sigc::trackable
   {
     <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>) {}
   };
   foo my_foo;
   <a class="code" href="classsigc_1_1slot.html">sigc::slot&lt;void, int&gt;</a> sl = <a class="code" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602">sigc::mem_fun</a>(my_foo, &amp;foo::bar);
</pre></div></dd></dl>
For const methods <a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602">mem_fun()</a> takes a const reference or pointer to an object.<p>
<dl class="user" compact><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment">   <span class="keyword">struct </span>foo : <span class="keyword">public</span> sigc::trackable
   {
     <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>)<span class="keyword"> const </span>{}
   };
   <span class="keyword">const</span> foo my_foo;
   <a class="code" href="classsigc_1_1slot.html">sigc::slot&lt;void, int&gt;</a> sl = <a class="code" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602">sigc::mem_fun</a>(my_foo, &amp;foo::bar);
</pre></div></dd></dl>
Use mem_fun#() if there is an abiguity as to the number of arguments.<p>
<dl class="user" compact><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment">   <span class="keyword">struct </span>foo : <span class="keyword">public</span> sigc::trackable
   {
     <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>) {}
     <span class="keywordtype">void</span> bar(<span class="keywordtype">float</span>) {}
     <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>) {}
   };
   foo my_foo;
   <a class="code" href="classsigc_1_1slot.html">sigc::slot&lt;void, int&gt;</a> sl = sigc::mem_fun1&lt;int&gt;(my_foo, &amp;foo::bar);
</pre></div> </dd></dl>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gcdcec06e66f0ba9a970e530c953d60b6"></a><!-- doxytag: member="sigc::mem_fun" ref="gcdcec06e66f0ba9a970e530c953d60b6" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_obj *&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gfc3676e579d8e7b037c0589b2ab12270"></a><!-- doxytag: member="sigc::mem_fun" ref="gfc3676e579d8e7b037c0589b2ab12270" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_obj *&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8fbf4b5621eda8f79ba2be75bd7badd4"></a><!-- doxytag: member="sigc::mem_fun" ref="g8fbf4b5621eda8f79ba2be75bd7badd4" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_obj *&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb1b6c289aa5b68e382c259bb5c35aa95"></a><!-- doxytag: member="sigc::mem_fun" ref="gb1b6c289aa5b68e382c259bb5c35aa95" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_obj *&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4) const&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc41f442c5e8a533e98cce0d7df02efe6"></a><!-- doxytag: member="sigc::mem_fun" ref="gc41f442c5e8a533e98cce0d7df02efe6" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_obj *&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3) const&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g34e7257908fb33b2582f686ac51e1d74"></a><!-- doxytag: member="sigc::mem_fun" ref="g34e7257908fb33b2582f686ac51e1d74" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_obj *&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2) const&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g23120ad94420b72a8761423c5bab2bec"></a><!-- doxytag: member="sigc::mem_fun" ref="g23120ad94420b72a8761423c5bab2bec" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_obj *&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1) const&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gdd76171e23f2e904c7f01264228440fc"></a><!-- doxytag: member="sigc::mem_fun" ref="gdd76171e23f2e904c7f01264228440fc" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)() const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_obj *&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)() const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb37fdbceea44a66560bb16345e1593e6"></a><!-- doxytag: member="sigc::mem_fun" ref="gb37fdbceea44a66560bb16345e1593e6" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) ) { return bound_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; mem_fun(/* </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g975cacf1b6fdd69a93c2f5ba0973f780"></a><!-- doxytag: member="sigc::mem_fun" ref="g975cacf1b6fdd69a93c2f5ba0973f780" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) ) { return bound_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; mem_fun(/* </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g81b830d633d756ca945bac75c4b2f8e8"></a><!-- doxytag: member="sigc::mem_fun" ref="g81b830d633d756ca945bac75c4b2f8e8" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) ) { return bound_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; mem_fun(/* </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g1b200788ce261aef52a8dadaa1e2c9aa"></a><!-- doxytag: member="sigc::mem_fun" ref="g1b200788ce261aef52a8dadaa1e2c9aa" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) ) { return bound_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt; mem_fun(/* </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g6e58e3cf7e4f1b5fbcb85736369d018c"></a><!-- doxytag: member="sigc::mem_fun" ref="g6e58e3cf7e4f1b5fbcb85736369d018c" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) ) { return bound_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt; mem_fun(/* </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g47ec248386b6998e5f8b9a80191e4d5d"></a><!-- doxytag: member="sigc::mem_fun" ref="g47ec248386b6998e5f8b9a80191e4d5d" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) ) { return bound_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt; mem_fun(/* </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="ge53b7ef4bd43363998aff8a589bc254a"></a><!-- doxytag: member="sigc::mem_fun" ref="ge53b7ef4bd43363998aff8a589bc254a" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) ) { return bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun(/* </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g51fa4e5052666f6738abbaa628ec6cc2"></a><!-- doxytag: member="sigc::mem_fun" ref="g51fa4e5052666f6738abbaa628ec6cc2" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)()&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)() ) { return bound_mem_functor0&lt;T_return, T_obj&gt;(_A_obj, _A_func); }<p>
template &lt;class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor0&lt;T_return, T_obj&gt; mem_fun(/* </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="gf995826321b8808ce8839e4abbb0550d"></a><!-- doxytag: member="sigc::mem_fun" ref="gf995826321b8808ce8839e4abbb0550d" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gdbb4cac2850f0f61f6d5f9e17e02c7ba"></a><!-- doxytag: member="sigc::mem_fun" ref="gdbb4cac2850f0f61f6d5f9e17e02c7ba" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g72ce5f7bfd24897f48d0ebd676bcbe5a"></a><!-- doxytag: member="sigc::mem_fun" ref="g72ce5f7bfd24897f48d0ebd676bcbe5a" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g17d792c86d3251c2045987c4dec04494"></a><!-- doxytag: member="sigc::mem_fun" ref="g17d792c86d3251c2045987c4dec04494" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8a171185d53c5ef87adb18bdd1d34aca"></a><!-- doxytag: member="sigc::mem_fun" ref="g8a171185d53c5ef87adb18bdd1d34aca" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g13a02e1edfe8b4450aba9f9629c69183"></a><!-- doxytag: member="sigc::mem_fun" ref="g13a02e1edfe8b4450aba9f9629c69183" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gfa7e13948472a451e25485f2c5001028"></a><!-- doxytag: member="sigc::mem_fun" ref="gfa7e13948472a451e25485f2c5001028" args="(T_return(T_obj::*_A_func)(T_arg1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7d9ea809173f48bf5c76cf1989591602"></a><!-- doxytag: member="sigc::mem_fun" ref="g7d9ea809173f48bf5c76cf1989591602" args="(T_return(T_obj::*_A_func)())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor0&lt; T_return, T_obj &gt; sigc::mem_fun           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)()&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc725cb282b0c611c67a270a7821e173f"></a><!-- doxytag: member="sigc::mem_fun0" ref="gc725cb282b0c611c67a270a7821e173f" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)() const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt; sigc::mem_fun0           </td>
          <td>(</td>
          <td class="paramtype">T_obj *&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)() const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge75bc5b94c36e78775ff5b5f20767baf"></a><!-- doxytag: member="sigc::mem_fun0" ref="ge75bc5b94c36e78775ff5b5f20767baf" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt; sigc::mem_fun0           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)()&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)() ) { return bound_mem_functor0&lt;T_return, T_obj&gt;(_A_obj, _A_func); }<p>
template &lt;class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor0&lt;T_return, T_obj&gt; mem_fun0(/* </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="gd6f8ec28efe46a939923e0ae83aa2888"></a><!-- doxytag: member="sigc::mem_fun0" ref="gd6f8ec28efe46a939923e0ae83aa2888" args="(T_return(T_obj::*_A_func)())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor0&lt; T_return, T_obj &gt; sigc::mem_fun0           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)()&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g211bd1f151b5936a549a8d8e6ab911bf"></a><!-- doxytag: member="sigc::mem_fun1" ref="g211bd1f151b5936a549a8d8e6ab911bf" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; sigc::mem_fun1           </td>
          <td>(</td>
          <td class="paramtype">T_obj *&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1) const&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3d62fea84f3f77ac5a315cebe5286b47"></a><!-- doxytag: member="sigc::mem_fun1" ref="g3d62fea84f3f77ac5a315cebe5286b47" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; sigc::mem_fun1           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) ) { return bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun1(/* </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="gc54cbcf11289d7b7fe15dff1fc2e84f4"></a><!-- doxytag: member="sigc::mem_fun1" ref="gc54cbcf11289d7b7fe15dff1fc2e84f4" args="(T_return(T_obj::*_A_func)(T_arg1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; sigc::mem_fun1           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g55aafe144e22f4df7fe785c1eec839ca"></a><!-- doxytag: member="sigc::mem_fun2" ref="g55aafe144e22f4df7fe785c1eec839ca" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; sigc::mem_fun2           </td>
          <td>(</td>
          <td class="paramtype">T_obj *&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2) const&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbb30783d2b0ac099089d70274d4459fb"></a><!-- doxytag: member="sigc::mem_fun2" ref="gbb30783d2b0ac099089d70274d4459fb" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; sigc::mem_fun2           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) ) { return bound_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt; mem_fun2(/* </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g353bb1c7c03796bafe5ed2e52f012980"></a><!-- doxytag: member="sigc::mem_fun2" ref="g353bb1c7c03796bafe5ed2e52f012980" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; sigc::mem_fun2           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3b7fd6101534e982aa29c0308ce69006"></a><!-- doxytag: member="sigc::mem_fun3" ref="g3b7fd6101534e982aa29c0308ce69006" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; sigc::mem_fun3           </td>
          <td>(</td>
          <td class="paramtype">T_obj *&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3) const&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf19bbb21b4b903e1a6b97fea87e90663"></a><!-- doxytag: member="sigc::mem_fun3" ref="gf19bbb21b4b903e1a6b97fea87e90663" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; sigc::mem_fun3           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) ) { return bound_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt; mem_fun3(/* </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="ga603c1c92cc9140a13d89256724de663"></a><!-- doxytag: member="sigc::mem_fun3" ref="ga603c1c92cc9140a13d89256724de663" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; sigc::mem_fun3           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gdedf83e65a2aca0d3aa4ac0b6d68ccd8"></a><!-- doxytag: member="sigc::mem_fun4" ref="gdedf83e65a2aca0d3aa4ac0b6d68ccd8" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; sigc::mem_fun4           </td>
          <td>(</td>
          <td class="paramtype">T_obj *&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4) const&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb1a00dd97f2ca5e21b2b4f73fea4053b"></a><!-- doxytag: member="sigc::mem_fun4" ref="gb1a00dd97f2ca5e21b2b4f73fea4053b" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; sigc::mem_fun4           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) ) { return bound_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt; mem_fun4(/* </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g9e5cce0968f3f2a79240922ebc1b6745"></a><!-- doxytag: member="sigc::mem_fun4" ref="g9e5cce0968f3f2a79240922ebc1b6745" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; sigc::mem_fun4           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g61cec9d9ec3d399f0d14a3b2edb6fecc"></a><!-- doxytag: member="sigc::mem_fun5" ref="g61cec9d9ec3d399f0d14a3b2edb6fecc" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; sigc::mem_fun5           </td>
          <td>(</td>
          <td class="paramtype">T_obj *&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const &nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga34194e868680c9146f8d143ddbdd8a8"></a><!-- doxytag: member="sigc::mem_fun5" ref="ga34194e868680c9146f8d143ddbdd8a8" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; sigc::mem_fun5           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) ) { return bound_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; mem_fun5(/* </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="gb0cbec1f295cbf8283208dedf5ab9ac7"></a><!-- doxytag: member="sigc::mem_fun5" ref="gb0cbec1f295cbf8283208dedf5ab9ac7" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; sigc::mem_fun5           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf6a1bce5fc8d6a117124874f2fa6ab18"></a><!-- doxytag: member="sigc::mem_fun6" ref="gf6a1bce5fc8d6a117124874f2fa6ab18" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; sigc::mem_fun6           </td>
          <td>(</td>
          <td class="paramtype">T_obj *&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4908458d042d70f91be5f72547518e4f"></a><!-- doxytag: member="sigc::mem_fun6" ref="g4908458d042d70f91be5f72547518e4f" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; sigc::mem_fun6           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) ) { return bound_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; mem_fun6(/* </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="g1c9c46a46db3d5d01d582b6867665c7c"></a><!-- doxytag: member="sigc::mem_fun6" ref="g1c9c46a46db3d5d01d582b6867665c7c" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; sigc::mem_fun6           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g208d42856768ebe922a1418f7250ca31"></a><!-- doxytag: member="sigc::mem_fun7" ref="g208d42856768ebe922a1418f7250ca31" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; sigc::mem_fun7           </td>
          <td>(</td>
          <td class="paramtype">T_obj *&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g750c42aaea61ec588daf64d4111e8429"></a><!-- doxytag: member="sigc::mem_fun7" ref="g750c42aaea61ec588daf64d4111e8429" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; sigc::mem_fun7           </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) ) { return bound_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; mem_fun7(/* </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="gfb7d7c8968bebcfea74f08c3eb55b14f"></a><!-- doxytag: member="sigc::mem_fun7" ref="gfb7d7c8968bebcfea74f08c3eb55b14f" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; sigc::mem_fun7           </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gaa2493ee4790a02fad2dfd44e3e4e1f6"></a><!-- doxytag: member="sigc::visit_each" ref="gaa2493ee4790a02fad2dfd44e3e4e1f6" args="(const T_action &amp;_A_action, const bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="gcb29a90ac86fe224d4074619e0117cb8"></a><!-- doxytag: member="sigc::visit_each" ref="gcb29a90ac86fe224d4074619e0117cb8" args="(const T_action &amp;_A_action, const bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g0a7438643be599bd0687c6de6af6ec2b"></a><!-- doxytag: member="sigc::visit_each" ref="g0a7438643be599bd0687c6de6af6ec2b" args="(const T_action &amp;_A_action, const bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="ge32dedba98d5616ffed3bf45564b5925"></a><!-- doxytag: member="sigc::visit_each" ref="ge32dedba98d5616ffed3bf45564b5925" args="(const T_action &amp;_A_action, const bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g4e8a4b740ba229328323782cdff5defc"></a><!-- doxytag: member="sigc::visit_each" ref="g4e8a4b740ba229328323782cdff5defc" args="(const T_action &amp;_A_action, const bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g8bbfab43840801b698deebdbcced31b8"></a><!-- doxytag: member="sigc::visit_each" ref="g8bbfab43840801b698deebdbcced31b8" args="(const T_action &amp;_A_action, const bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="gfa45bea25d6b97dd4215c61845eb276b"></a><!-- doxytag: member="sigc::visit_each" ref="gfa45bea25d6b97dd4215c61845eb276b" args="(const T_action &amp;_A_action, const bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g7f0b3a137305d0da984cfcaa69028645"></a><!-- doxytag: member="sigc::visit_each" ref="g7f0b3a137305d0da984cfcaa69028645" args="(const T_action &amp;_A_action, const bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="ged1e318f76b0b4560f7f7f15348bf74f"></a><!-- doxytag: member="sigc::visit_each" ref="ged1e318f76b0b4560f7f7f15348bf74f" args="(const T_action &amp;_A_action, const bound_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g4fe42d39978e3534528e704a2ef69d19"></a><!-- doxytag: member="sigc::visit_each" ref="g4fe42d39978e3534528e704a2ef69d19" args="(const T_action &amp;_A_action, const bound_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g59db8f4f6bf774aac7a42e4db22fe525"></a><!-- doxytag: member="sigc::visit_each" ref="g59db8f4f6bf774aac7a42e4db22fe525" args="(const T_action &amp;_A_action, const bound_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g115420b91c53ff373128c8d9c5389e26"></a><!-- doxytag: member="sigc::visit_each" ref="g115420b91c53ff373128c8d9c5389e26" args="(const T_action &amp;_A_action, const bound_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g8df64a5ef08edf9a3bffd45888cf6566"></a><!-- doxytag: member="sigc::visit_each" ref="g8df64a5ef08edf9a3bffd45888cf6566" args="(const T_action &amp;_A_action, const bound_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="gfd990e80dc9ec40599b0e66526334ed3"></a><!-- doxytag: member="sigc::visit_each" ref="gfd990e80dc9ec40599b0e66526334ed3" args="(const T_action &amp;_A_action, const bound_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="gc99d35f92c4859d7ba58c0f8dbee8a59"></a><!-- doxytag: member="sigc::visit_each" ref="gc99d35f92c4859d7ba58c0f8dbee8a59" args="(const T_action &amp;_A_action, const bound_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g167fc8e84727e8b465c5f569da18fe7c"></a><!-- doxytag: member="sigc::visit_each" ref="g167fc8e84727e8b465c5f569da18fe7c" args="(const T_action &amp;_A_action, const bound_volatile_mem_functor0&lt; T_return, T_obj &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor0&lt; T_return, T_obj &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="gf8ba948d4075a160a3c887d5bc29fe38"></a><!-- doxytag: member="sigc::visit_each" ref="gf8ba948d4075a160a3c887d5bc29fe38" args="(const T_action &amp;_A_action, const bound_const_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g5af2a45e22e6f53837fa0b5f9de0ad57"></a><!-- doxytag: member="sigc::visit_each" ref="g5af2a45e22e6f53837fa0b5f9de0ad57" args="(const T_action &amp;_A_action, const bound_const_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g21e843c71a56dba1d507c9a92fad48d1"></a><!-- doxytag: member="sigc::visit_each" ref="g21e843c71a56dba1d507c9a92fad48d1" args="(const T_action &amp;_A_action, const bound_const_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g6bbf2084c41ca86d2ab99e21adf28f30"></a><!-- doxytag: member="sigc::visit_each" ref="g6bbf2084c41ca86d2ab99e21adf28f30" args="(const T_action &amp;_A_action, const bound_const_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="ga3c16c17557fcebdd7573fa6b2ed0dcf"></a><!-- doxytag: member="sigc::visit_each" ref="ga3c16c17557fcebdd7573fa6b2ed0dcf" args="(const T_action &amp;_A_action, const bound_const_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g8ef4b45b1dcecb9270562c030e38e339"></a><!-- doxytag: member="sigc::visit_each" ref="g8ef4b45b1dcecb9270562c030e38e339" args="(const T_action &amp;_A_action, const bound_const_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g20b2c11c8fb2a9e0bb86ad4c66c9c2e7"></a><!-- doxytag: member="sigc::visit_each" ref="g20b2c11c8fb2a9e0bb86ad4c66c9c2e7" args="(const T_action &amp;_A_action, const bound_const_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="ga0d89783277d6e9dede11eda2ff6c75a"></a><!-- doxytag: member="sigc::visit_each" ref="ga0d89783277d6e9dede11eda2ff6c75a" args="(const T_action &amp;_A_action, const bound_const_mem_functor0&lt; T_return, T_obj &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor0&lt; T_return, T_obj &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g56f7d4d8f86928edb83e1f65702a2978"></a><!-- doxytag: member="sigc::visit_each" ref="g56f7d4d8f86928edb83e1f65702a2978" args="(const T_action &amp;_A_action, const bound_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g259c308cca0572400aaed34384eafbe3"></a><!-- doxytag: member="sigc::visit_each" ref="g259c308cca0572400aaed34384eafbe3" args="(const T_action &amp;_A_action, const bound_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="gee9534127cddea3f7b3e5461f768a42b"></a><!-- doxytag: member="sigc::visit_each" ref="gee9534127cddea3f7b3e5461f768a42b" args="(const T_action &amp;_A_action, const bound_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g66608a108aa332faf3c3bfd418655fcb"></a><!-- doxytag: member="sigc::visit_each" ref="g66608a108aa332faf3c3bfd418655fcb" args="(const T_action &amp;_A_action, const bound_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g5cc57f71faadc4101e7a10e0b5d7317f"></a><!-- doxytag: member="sigc::visit_each" ref="g5cc57f71faadc4101e7a10e0b5d7317f" args="(const T_action &amp;_A_action, const bound_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g497c57551529e8721861cedc1c3d5121"></a><!-- doxytag: member="sigc::visit_each" ref="g497c57551529e8721861cedc1c3d5121" args="(const T_action &amp;_A_action, const bound_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="gff3264460325cf2a34cc0502fec7b8b7"></a><!-- doxytag: member="sigc::visit_each" ref="gff3264460325cf2a34cc0502fec7b8b7" args="(const T_action &amp;_A_action, const bound_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. 
</div>
</div><p>
<a class="anchor" name="g8a0e4bdca79dde7347318bff4d6e1eda"></a><!-- doxytag: member="sigc::visit_each" ref="g8a0e4bdca79dde7347318bff4d6e1eda" args="(const T_action &amp;_A_action, const bound_mem_functor0&lt; T_return, T_obj &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_return, class T_obj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor0&lt; T_return, T_obj &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. 
</div>
</div><p>
<hr><address><small>
Generated for libsigc++ 2.0 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.5.1 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
