<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libsigc++ 2.0: mem_fun.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/libsigc_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="../../index.html">Main Page</a> &nbsp;
  <a class="qindex" href="modules.html">Groups</a> &nbsp;
  <a class="qindex" href="namespaces.html"> Namespaces</a> &nbsp;
</center>
<hr width="100%"/>

<!-- Generated by Doxygen 1.5.1 -->
<h1>mem_fun.h File Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesigc.html">sigc</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor0.html">sigc::mem_functor0&lt;T_return, T_obj&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a> wraps methods with 0 argument(s).  <a href="classsigc_1_1mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor1.html">sigc::mem_functor1&lt;T_return, T_obj, T_arg1&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a> wraps methods with 1 argument(s).  <a href="classsigc_1_1mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor2.html">sigc::mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a> wraps methods with 2 argument(s).  <a href="classsigc_1_1mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor3.html">sigc::mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a> wraps methods with 3 argument(s).  <a href="classsigc_1_1mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor4.html">sigc::mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a> wraps methods with 4 argument(s).  <a href="classsigc_1_1mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor5.html">sigc::mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a> wraps methods with 5 argument(s).  <a href="classsigc_1_1mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor6.html">sigc::mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a> wraps methods with 6 argument(s).  <a href="classsigc_1_1mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor7.html">sigc::mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a> wraps methods with 7 argument(s).  <a href="classsigc_1_1mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor0.html">sigc::const_mem_functor0&lt;T_return, T_obj&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a> wraps const methods with 0 argument(s).  <a href="classsigc_1_1const__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor1.html">sigc::const_mem_functor1&lt;T_return, T_obj, T_arg1&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a> wraps const methods with 1 argument(s).  <a href="classsigc_1_1const__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor2.html">sigc::const_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a> wraps const methods with 2 argument(s).  <a href="classsigc_1_1const__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor3.html">sigc::const_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a> wraps const methods with 3 argument(s).  <a href="classsigc_1_1const__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor4.html">sigc::const_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a> wraps const methods with 4 argument(s).  <a href="classsigc_1_1const__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor5.html">sigc::const_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a> wraps const methods with 5 argument(s).  <a href="classsigc_1_1const__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor6.html">sigc::const_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a> wraps const methods with 6 argument(s).  <a href="classsigc_1_1const__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor7.html">sigc::const_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a> wraps const methods with 7 argument(s).  <a href="classsigc_1_1const__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor0.html">sigc::volatile_mem_functor0&lt;T_return, T_obj&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a> wraps volatile methods with 0 argument(s).  <a href="classsigc_1_1volatile__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor1.html">sigc::volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a> wraps volatile methods with 1 argument(s).  <a href="classsigc_1_1volatile__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor2.html">sigc::volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a> wraps volatile methods with 2 argument(s).  <a href="classsigc_1_1volatile__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor3.html">sigc::volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a> wraps volatile methods with 3 argument(s).  <a href="classsigc_1_1volatile__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor4.html">sigc::volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a> wraps volatile methods with 4 argument(s).  <a href="classsigc_1_1volatile__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor5.html">sigc::volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a> wraps volatile methods with 5 argument(s).  <a href="classsigc_1_1volatile__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor6.html">sigc::volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a> wraps volatile methods with 6 argument(s).  <a href="classsigc_1_1volatile__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor7.html">sigc::volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a> wraps volatile methods with 7 argument(s).  <a href="classsigc_1_1volatile__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">sigc::const_volatile_mem_functor0&lt;T_return, T_obj&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a> wraps const volatile methods with 0 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">sigc::const_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a> wraps const volatile methods with 1 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">sigc::const_volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a> wraps const volatile methods with 2 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">sigc::const_volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a> wraps const volatile methods with 3 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">sigc::const_volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a> wraps const volatile methods with 4 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">sigc::const_volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a> wraps const volatile methods with 5 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">sigc::const_volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a> wraps const volatile methods with 6 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">sigc::const_volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a> wraps const volatile methods with 7 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor0.html">sigc::bound_mem_functor0&lt;T_return, T_obj&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a> encapsulates a method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor1.html">sigc::bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a> encapsulates a method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor2.html">sigc::bound_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a> encapsulates a method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor3.html">sigc::bound_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a> encapsulates a method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor4.html">sigc::bound_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a> encapsulates a method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor5.html">sigc::bound_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a> encapsulates a method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor6.html">sigc::bound_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a> encapsulates a method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor7.html">sigc::bound_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a> encapsulates a method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">sigc::bound_const_mem_functor0&lt;T_return, T_obj&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a> encapsulates a const method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">sigc::bound_const_mem_functor1&lt;T_return, T_obj, T_arg1&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a> encapsulates a const method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">sigc::bound_const_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a> encapsulates a const method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">sigc::bound_const_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a> encapsulates a const method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">sigc::bound_const_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a> encapsulates a const method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">sigc::bound_const_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a> encapsulates a const method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">sigc::bound_const_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a> encapsulates a const method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">sigc::bound_const_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a> encapsulates a const method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">sigc::bound_volatile_mem_functor0&lt;T_return, T_obj&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a> encapsulates a volatile method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">sigc::bound_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a> encapsulates a volatile method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">sigc::bound_volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a> encapsulates a volatile method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">sigc::bound_volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a> encapsulates a volatile method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">sigc::bound_volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a> encapsulates a volatile method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">sigc::bound_volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a> encapsulates a volatile method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">sigc::bound_volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a> encapsulates a volatile method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">sigc::bound_volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a> encapsulates a volatile method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0&lt;T_return, T_obj&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a> encapsulates a const volatile method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a> encapsulates a const volatile method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a> encapsulates a const volatile method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a> encapsulates a const volatile method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a> encapsulates a const volatile method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a> encapsulates a const volatile method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a> encapsulates a const volatile method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a> encapsulates a const volatile method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g8a0e4bdca79dde7347318bff4d6e1eda">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor0&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g8a0e4bdca79dde7347318bff4d6e1eda"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gff3264460325cf2a34cc0502fec7b8b7">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#gff3264460325cf2a34cc0502fec7b8b7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g497c57551529e8721861cedc1c3d5121">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g497c57551529e8721861cedc1c3d5121"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g5cc57f71faadc4101e7a10e0b5d7317f">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g5cc57f71faadc4101e7a10e0b5d7317f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g66608a108aa332faf3c3bfd418655fcb">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g66608a108aa332faf3c3bfd418655fcb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gee9534127cddea3f7b3e5461f768a42b">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#gee9534127cddea3f7b3e5461f768a42b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g259c308cca0572400aaed34384eafbe3">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g259c308cca0572400aaed34384eafbe3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g56f7d4d8f86928edb83e1f65702a2978">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g56f7d4d8f86928edb83e1f65702a2978"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga0d89783277d6e9dede11eda2ff6c75a">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor0&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#ga0d89783277d6e9dede11eda2ff6c75a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g20b2c11c8fb2a9e0bb86ad4c66c9c2e7">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor1&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g20b2c11c8fb2a9e0bb86ad4c66c9c2e7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g8ef4b45b1dcecb9270562c030e38e339">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g8ef4b45b1dcecb9270562c030e38e339"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3c16c17557fcebdd7573fa6b2ed0dcf">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#ga3c16c17557fcebdd7573fa6b2ed0dcf"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g6bbf2084c41ca86d2ab99e21adf28f30">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g6bbf2084c41ca86d2ab99e21adf28f30"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g21e843c71a56dba1d507c9a92fad48d1">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g21e843c71a56dba1d507c9a92fad48d1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g5af2a45e22e6f53837fa0b5f9de0ad57">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g5af2a45e22e6f53837fa0b5f9de0ad57"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gf8ba948d4075a160a3c887d5bc29fe38">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#gf8ba948d4075a160a3c887d5bc29fe38"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g167fc8e84727e8b465c5f569da18fe7c">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor0&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g167fc8e84727e8b465c5f569da18fe7c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gc99d35f92c4859d7ba58c0f8dbee8a59">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#gc99d35f92c4859d7ba58c0f8dbee8a59"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gfd990e80dc9ec40599b0e66526334ed3">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#gfd990e80dc9ec40599b0e66526334ed3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g8df64a5ef08edf9a3bffd45888cf6566">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g8df64a5ef08edf9a3bffd45888cf6566"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g115420b91c53ff373128c8d9c5389e26">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g115420b91c53ff373128c8d9c5389e26"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g59db8f4f6bf774aac7a42e4db22fe525">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g59db8f4f6bf774aac7a42e4db22fe525"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g4fe42d39978e3534528e704a2ef69d19">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g4fe42d39978e3534528e704a2ef69d19"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ged1e318f76b0b4560f7f7f15348bf74f">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#ged1e318f76b0b4560f7f7f15348bf74f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g7f0b3a137305d0da984cfcaa69028645">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor0&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g7f0b3a137305d0da984cfcaa69028645"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gfa45bea25d6b97dd4215c61845eb276b">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#gfa45bea25d6b97dd4215c61845eb276b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g8bbfab43840801b698deebdbcced31b8">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g8bbfab43840801b698deebdbcced31b8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g4e8a4b740ba229328323782cdff5defc">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g4e8a4b740ba229328323782cdff5defc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ge32dedba98d5616ffed3bf45564b5925">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#ge32dedba98d5616ffed3bf45564b5925"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g0a7438643be599bd0687c6de6af6ec2b">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g0a7438643be599bd0687c6de6af6ec2b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gcb29a90ac86fe224d4074619e0117cb8">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#gcb29a90ac86fe224d4074619e0117cb8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaa2493ee4790a02fad2dfd44e3e4e1f6">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#gaa2493ee4790a02fad2dfd44e3e4e1f6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor0&lt;T_return, T_obj&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gd6f8ec28efe46a939923e0ae83aa2888">sigc::mem_fun0</a> (T_return(T_obj::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method.  <a href="group__mem__fun.html#gd6f8ec28efe46a939923e0ae83aa2888"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor1&lt; T_return, T_obj,<br>
 T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gc54cbcf11289d7b7fe15dff1fc2e84f4">sigc::mem_fun1</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method.  <a href="group__mem__fun.html#gc54cbcf11289d7b7fe15dff1fc2e84f4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor2&lt; T_return, T_obj,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g353bb1c7c03796bafe5ed2e52f012980">sigc::mem_fun2</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method.  <a href="group__mem__fun.html#g353bb1c7c03796bafe5ed2e52f012980"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor3&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga603c1c92cc9140a13d89256724de663">sigc::mem_fun3</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method.  <a href="group__mem__fun.html#ga603c1c92cc9140a13d89256724de663"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor4&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g9e5cce0968f3f2a79240922ebc1b6745">sigc::mem_fun4</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method.  <a href="group__mem__fun.html#g9e5cce0968f3f2a79240922ebc1b6745"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor5&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gb0cbec1f295cbf8283208dedf5ab9ac7">sigc::mem_fun5</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method.  <a href="group__mem__fun.html#gb0cbec1f295cbf8283208dedf5ab9ac7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor6&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g1c9c46a46db3d5d01d582b6867665c7c">sigc::mem_fun6</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method.  <a href="group__mem__fun.html#g1c9c46a46db3d5d01d582b6867665c7c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor7&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gfb7d7c8968bebcfea74f08c3eb55b14f">sigc::mem_fun7</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method.  <a href="group__mem__fun.html#gfb7d7c8968bebcfea74f08c3eb55b14f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor0&lt; T_return,<br>
 T_obj &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ge75bc5b94c36e78775ff5b5f20767baf">sigc::mem_fun0</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ge75bc5b94c36e78775ff5b5f20767baf"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor1&lt; T_return,<br>
 T_obj, T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g3d62fea84f3f77ac5a315cebe5286b47">sigc::mem_fun1</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g3d62fea84f3f77ac5a315cebe5286b47"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor2&lt; T_return,<br>
 T_obj, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gbb30783d2b0ac099089d70274d4459fb">sigc::mem_fun2</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gbb30783d2b0ac099089d70274d4459fb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor3&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gf19bbb21b4b903e1a6b97fea87e90663">sigc::mem_fun3</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gf19bbb21b4b903e1a6b97fea87e90663"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor4&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gb1a00dd97f2ca5e21b2b4f73fea4053b">sigc::mem_fun4</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gb1a00dd97f2ca5e21b2b4f73fea4053b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor5&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga34194e868680c9146f8d143ddbdd8a8">sigc::mem_fun5</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga34194e868680c9146f8d143ddbdd8a8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor6&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g4908458d042d70f91be5f72547518e4f">sigc::mem_fun6</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g4908458d042d70f91be5f72547518e4f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor7&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g750c42aaea61ec588daf64d4111e8429">sigc::mem_fun7</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g750c42aaea61ec588daf64d4111e8429"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor0&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gc725cb282b0c611c67a270a7821e173f">sigc::mem_fun0</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gc725cb282b0c611c67a270a7821e173f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor1&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g211bd1f151b5936a549a8d8e6ab911bf">sigc::mem_fun1</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g211bd1f151b5936a549a8d8e6ab911bf"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor2&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g55aafe144e22f4df7fe785c1eec839ca">sigc::mem_fun2</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g55aafe144e22f4df7fe785c1eec839ca"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor3&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g3b7fd6101534e982aa29c0308ce69006">sigc::mem_fun3</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g3b7fd6101534e982aa29c0308ce69006"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor4&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gdedf83e65a2aca0d3aa4ac0b6d68ccd8">sigc::mem_fun4</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gdedf83e65a2aca0d3aa4ac0b6d68ccd8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor5&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g61cec9d9ec3d399f0d14a3b2edb6fecc">sigc::mem_fun5</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g61cec9d9ec3d399f0d14a3b2edb6fecc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor6&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gf6a1bce5fc8d6a117124874f2fa6ab18">sigc::mem_fun6</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gf6a1bce5fc8d6a117124874f2fa6ab18"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor7&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g208d42856768ebe922a1418f7250ca31">sigc::mem_fun7</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g208d42856768ebe922a1418f7250ca31"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor0&lt;T_return, T_obj&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602">sigc::mem_fun</a> (T_return(T_obj::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method.  <a href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor1&lt; T_return, T_obj,<br>
 T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gfa7e13948472a451e25485f2c5001028">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method.  <a href="group__mem__fun.html#gfa7e13948472a451e25485f2c5001028"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor2&lt; T_return, T_obj,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g13a02e1edfe8b4450aba9f9629c69183">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method.  <a href="group__mem__fun.html#g13a02e1edfe8b4450aba9f9629c69183"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor3&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g8a171185d53c5ef87adb18bdd1d34aca">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method.  <a href="group__mem__fun.html#g8a171185d53c5ef87adb18bdd1d34aca"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor4&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g17d792c86d3251c2045987c4dec04494">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method.  <a href="group__mem__fun.html#g17d792c86d3251c2045987c4dec04494"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor5&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g72ce5f7bfd24897f48d0ebd676bcbe5a">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method.  <a href="group__mem__fun.html#g72ce5f7bfd24897f48d0ebd676bcbe5a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor6&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gdbb4cac2850f0f61f6d5f9e17e02c7ba">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method.  <a href="group__mem__fun.html#gdbb4cac2850f0f61f6d5f9e17e02c7ba"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mem_functor7&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gf995826321b8808ce8839e4abbb0550d">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method.  <a href="group__mem__fun.html#gf995826321b8808ce8839e4abbb0550d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor0&lt; T_return,<br>
 T_obj &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g51fa4e5052666f6738abbaa628ec6cc2">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g51fa4e5052666f6738abbaa628ec6cc2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor1&lt; T_return,<br>
 T_obj, T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ge53b7ef4bd43363998aff8a589bc254a">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ge53b7ef4bd43363998aff8a589bc254a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor2&lt; T_return,<br>
 T_obj, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g47ec248386b6998e5f8b9a80191e4d5d">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g47ec248386b6998e5f8b9a80191e4d5d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor3&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g6e58e3cf7e4f1b5fbcb85736369d018c">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g6e58e3cf7e4f1b5fbcb85736369d018c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor4&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g1b200788ce261aef52a8dadaa1e2c9aa">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g1b200788ce261aef52a8dadaa1e2c9aa"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor5&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g81b830d633d756ca945bac75c4b2f8e8">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g81b830d633d756ca945bac75c4b2f8e8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor6&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g975cacf1b6fdd69a93c2f5ba0973f780">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g975cacf1b6fdd69a93c2f5ba0973f780"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_mem_functor7&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gb37fdbceea44a66560bb16345e1593e6">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gb37fdbceea44a66560bb16345e1593e6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor0&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gdd76171e23f2e904c7f01264228440fc">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gdd76171e23f2e904c7f01264228440fc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor1&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g23120ad94420b72a8761423c5bab2bec">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g23120ad94420b72a8761423c5bab2bec"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor2&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g34e7257908fb33b2582f686ac51e1d74">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g34e7257908fb33b2582f686ac51e1d74"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor3&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gc41f442c5e8a533e98cce0d7df02efe6">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gc41f442c5e8a533e98cce0d7df02efe6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor4&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gb1b6c289aa5b68e382c259bb5c35aa95">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gb1b6c289aa5b68e382c259bb5c35aa95"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor5&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g8fbf4b5621eda8f79ba2be75bd7badd4">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g8fbf4b5621eda8f79ba2be75bd7badd4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor6&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gfc3676e579d8e7b037c0589b2ab12270">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gfc3676e579d8e7b037c0589b2ab12270"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bound_const_mem_functor7&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gcdcec06e66f0ba9a970e530c953d60b6">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gcdcec06e66f0ba9a970e530c953d60b6"></a><br></td></tr>
</table>
<hr><address><small>
Generated for libsigc++ 2.0 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.5.1 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
